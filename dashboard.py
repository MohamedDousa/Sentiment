# -*- coding: utf-8 -*-
"""dashboard.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1h5jKEAgeXA9i8KfegWpUxIOMPNMrkQjT
"""

# dashboard.py - Streamlit frontend
import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import requests
import json
import io
from datetime import datetime
import plotly.express as px
import plotly.graph_objects as go
import traceback

# Set page configuration
st.set_page_config(
    page_title="Feedback Analysis Dashboard",
    page_icon="ðŸ“Š",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Define API endpoint
API_URL = "http://localhost:8000"  # Update with your FastAPI server URL

# Function to check API connection
def check_api_connection():
    try:
        response = requests.get(f"{API_URL}/")
        return response.status_code == 200
    except Exception as e:
        st.sidebar.error(f"API connection error: {str(e)}")
        return False

# Function to upload file to API
def upload_file(file):
    try:
        files = {"file": file}
        response = requests.post(f"{API_URL}/upload", files=files)
        if response.status_code != 200:
            st.error(f"API returned status code {response.status_code}: {response.text}")
            return None
            
        response_data = response.json()
        # Assuming your API response contains comments_processed and departments_processed
        return {
            "comments_processed": response_data.get("comments_processed", 0),
            "departments_processed": response_data.get("departments_processed", 0)
            # Other keys from response_data if needed
        }
    except Exception as e:
        st.error(f"Error uploading file: {str(e)}")
        st.error(f"Traceback: {traceback.format_exc()}")
        return None

# Function to get all risk scores
def get_all_risks():
    try:
        response = requests.get(f"{API_URL}/risk/all")

        # Debug information
        st.sidebar.write(f"Debug - Risk API Response Status: {response.status_code}")
        
        # Check if the response status is OK
        if response.status_code == 200:
            data = response.json()
            
            # Debug the actual response content
            st.sidebar.write(f"Debug - Risk API Response Content (sample): {str(data)[:200]}...")

            # Check the data type
            if isinstance(data, list) and len(data) > 0:
                return data
            else:
                st.sidebar.warning(f"Debug - Unexpected risk data format: {type(data)}")
                # Attempt to handle various formats
                if isinstance(data, dict) and "departments" in data:
                    return data.get("departments", [])
                elif isinstance(data, dict):
                    # Try to convert dict to list of dicts
                    return [{"department": k, "risk_score": v, "high_risk": False} for k, v in data.items()]
                else:
                    return []
        else:
            st.sidebar.error(f"Debug - Risk API error: {response.status_code}")
            st.sidebar.error(f"Response content: {response.text}")
            return []
    except Exception as e:
        st.sidebar.error(f"Debug - Error fetching risks: {str(e)}")
        st.sidebar.error(f"Traceback: {traceback.format_exc()}")
        return []

# Function to get department list
def get_departments():
    try:
        response = requests.get(f"{API_URL}/departments")
        if response.status_code != 200:
            st.sidebar.error(f"Departments API error: {response.status_code}: {response.text}")
            return []
        return response.json().get("departments", [])
    except Exception as e:
        st.sidebar.error(f"Error fetching departments: {str(e)}")
        return []

# Function to get theme summary
def get_themes_summary():
    try:
        response = requests.get(f"{API_URL}/themes/summary")
        if response.status_code != 200:
            st.sidebar.error(f"Themes API error: {response.status_code}: {response.text}")
            return {}
        return response.json().get("themes", {})
    except Exception as e:
        st.sidebar.error(f"Error fetching themes: {str(e)}")
        return {}

# Function to get data summary
def get_data_summary():
    try:
        response = requests.get(f"{API_URL}/data/summary")
        if response.status_code != 200:
            st.sidebar.error(f"Data summary API error: {response.status_code}: {response.text}")
            return None
        return response.json()
    except Exception as e:
        st.sidebar.error(f"Error fetching data summary: {str(e)}")
        return None

# Function to get sample comments
def get_sample_comments(department=None, theme=None, limit=5):
    try:
        params = {}
        if department:
            params["department"] = department
        if theme:
            params["theme"] = theme
        if limit:
            params["limit"] = limit

        response = requests.get(f"{API_URL}/comments/sample", params=params)
        if response.status_code != 200:
            st.error(f"Comments API error: {response.status_code}: {response.text}")
            return []
        return response.json().get("samples", [])
    except Exception as e:
        st.error(f"Error fetching comments: {str(e)}")
        return []

# Function to get specific department risk
def get_department_risk(department):
    try:
        response = requests.get(f"{API_URL}/risk/{department}")
        if response.status_code != 200:
            st.error(f"Department risk API error: {response.status_code}: {response.text}")
            return None
        return response.json()
    except Exception as e:
        st.error(f"Error fetching department risk: {str(e)}")
        return None

# Sidebar for file upload and navigation
st.sidebar.title("Staff Feedback Analysis")

# Check API connection
if not check_api_connection():
    st.sidebar.error("âŒ Cannot connect to API server. Please make sure it's running.")
    st.error("Cannot connect to the API server. Please start the server with `uvicorn api:app --reload`")
    st.stop()
else:
    st.sidebar.success("âœ… Connected to API server")

# File upload
st.sidebar.header("Data Upload")
uploaded_file = st.sidebar.file_uploader("Upload Staff Feedback Data", type=["csv", "xlsx", "xls"])

if uploaded_file:
    if st.sidebar.button("Process Data"):
        with st.spinner("Processing data... This may take a minute."):
            result = upload_file(uploaded_file)
            if result:
                st.sidebar.success(f"âœ… Processed {result['comments_processed']} comments across {result['departments_processed']} departments")
            else:
                st.sidebar.error("âŒ Error processing file")

# Navigation
st.sidebar.header("Navigation")
page = st.sidebar.radio(
    "Select a page",
    ["Home", "Department Details", "Comment Explorer", "Themes Analysis", "Insights & Solutions", "About"]
)

# Get data from API
data_summary = get_data_summary()
all_risks = get_all_risks()
departments = get_departments()
themes_summary = get_themes_summary()

# Define all page functions first
def home_page():
    """Main dashboard home page"""
    st.title("Staff Feedback Analysis Dashboard")

    if not data_summary:
        st.info("No data loaded. Please upload a file using the sidebar.")
        st.stop()

    # Dashboard metrics row
    col1, col2, col3, col4 = st.columns(4)

    with col1:
        st.metric("Total Comments", data_summary.get("total_comments", 0))

    with col2:
        st.metric("Departments", data_summary.get("total_departments", 0))

    with col3:
        total_depts = data_summary.get("total_departments", 1)  # Default to 1 to avoid division by zero
        high_risk_depts = data_summary.get("high_risk_departments", 0)
        high_risk_pct = round(high_risk_depts / total_depts * 100) if total_depts > 0 else 0
        st.metric("High Risk Depts", f"{high_risk_depts} ({high_risk_pct}%)")

    with col4:
        total_comments = data_summary.get("total_comments", 1)  # Default to 1 to avoid division by zero
        sentiment_dist = data_summary.get("sentiment_distribution", {})
        negative_comments = sentiment_dist.get("negative", 0)
        negative_pct = round(negative_comments / total_comments * 100) if total_comments > 0 else 0
        st.metric("Negative Comments", f"{negative_comments} ({negative_pct}%)")

    # Sentiment distribution
    st.subheader("Sentiment Distribution")

    if data_summary and "sentiment_distribution" in data_summary:
        # Create sentiment data
        sentiment_data = []
        sentiment_dist = data_summary.get("sentiment_distribution", {})

        for sentiment, count in sentiment_dist.items():
            sentiment_data.append({
                "sentiment": sentiment.capitalize(),
                "count": count
            })

        if sentiment_data:
            sentiment_df = pd.DataFrame(sentiment_data)

            # Create Plotly pie chart
            try:
                fig = px.pie(
                    sentiment_df,
                    values="count",
                    names="sentiment",
                    title="Overall Sentiment Distribution",
                    color="sentiment",
                    color_discrete_map={
                        "Positive": "green",
                        "Neutral": "gray",
                        "Negative": "red"
                    }
                )
                st.plotly_chart(fig, use_container_width=True)
            except Exception as e:
                st.error(f"Error creating sentiment visualization: {str(e)}")
        else:
            st.info("No valid sentiment data available")
    else:
        st.info("No sentiment data available")
    
    # Theme summary
    if themes_summary:
        st.subheader("Top Themes Overview")
        
        # Create theme data for visualization
        theme_data = []
        for theme, count in themes_summary.items():
            # Skip themes containing "comment" as they skew results
            if "comment" in theme.lower():
                continue
            theme_data.append({
                "theme": theme,
                "count": count
            })

        if theme_data:
            theme_df = pd.DataFrame(theme_data)
            theme_df = theme_df.sort_values("count", ascending=False)
            
            # Display top 10 themes
            fig = px.bar(
                theme_df.head(10),
                x="theme",
                y="count",
                title="Top 10 Themes (excluding 'comment' themes)",
                labels={"theme": "Theme", "count": "Occurrence Count"},
                color="count",
                color_continuous_scale="Blues"
            )
            fig.update_layout(xaxis_tickangle=-45)
            st.plotly_chart(fig, use_container_width=True)
            
            # Highlight themes specific to civility and respect
            st.subheader("Key Civility & Respect Themes")
            
            # Filter for civility/respect related themes
            respect_themes = [
                'respect_communication', 'workplace_culture', 'leadership_behavior',
                'workplace_policies', 'inclusion_diversity', 'training_development',
                'recognition_appreciation'
            ]
            
            respect_theme_df = theme_df[theme_df['theme'].isin(respect_themes)]
            
            if not respect_theme_df.empty:
                # Create columns for visualization and recommendations
                col1, col2 = st.columns([3, 2])
                
                with col1:
                    fig = px.bar(
                        respect_theme_df.sort_values("count", ascending=False),
                        x="theme",
                        y="count",
                        title="Civility & Respect Themes",
                        labels={"theme": "Theme", "count": "Occurrence Count"},
                        color="count",
                        color_continuous_scale="Greens"
                    )
                    fig.update_layout(xaxis_tickangle=-45)
                    st.plotly_chart(fig, use_container_width=True)
                
                with col2:
                    st.markdown("""
                    ### Key Insights
                    
                    Based on staff feedback themes, focus on:
                    
                    1. **Communication** - Promote respectful dialogue
                    
                    2. **Leadership** - Encourage role modeling
                    
                    3. **Recognition** - Acknowledge positive behaviors
                    
                    For detailed analysis, visit the **Themes Analysis** page.
                    """)
            else:
                st.info("No civility and respect themes identified yet. Upload staff feedback data to see insights.")
        else:
            st.info("No theme data available")
    else:
        st.info("No theme data available")

def department_details():
    """Department details page"""
    st.title("Department Details")

    if not departments:
        st.info("No departments available. Please upload data first.")
        st.stop()

    # Department selector
    selected_dept = st.selectbox("Select Department", departments)

    if selected_dept:
        # Get department risk data
        dept_risk = get_department_risk(selected_dept)

        if dept_risk:
            # Department header with risk score
            col1, col2 = st.columns([3, 1])

            with col1:
                st.header(selected_dept)

            with col2:
                risk_color = "red" if dept_risk.get("high_risk", False) else "blue"
                risk_score = dept_risk.get("risk_score", 0)
                st.markdown(f"<h2 style='color:{risk_color};'>Risk: {risk_score:.1f}/5.0</h2>", unsafe_allow_html=True)

            # Theme analysis for this department
            st.subheader("Sample Comments")

            comments = get_sample_comments(department=selected_dept, limit=5)

            if comments and isinstance(comments, list):
                for i, comment in enumerate(comments):
                    if not isinstance(comment, dict):
                        continue

                    # Check if sentiment_score exists, use default if not
                    score = comment.get("sentiment_score", 0.5)
                    
                    # Convert score to sentiment category
                    sentiment_category = "NEUTRAL"
                    if score > 0.6:
                        sentiment_category = "POSITIVE"
                    elif score < 0.4:
                        sentiment_category = "NEGATIVE"

                    sentiment_color = {
                        "POSITIVE": "green",
                        "NEGATIVE": "red",
                        "NEUTRAL": "gray"
                    }.get(sentiment_category, "gray")

                    comment_text = comment.get("free_text_comments", "")

                    st.markdown(f"""
                    <div style="padding: 10px; border-left: 5px solid {sentiment_color}; background-color: rgba(0,0,0,0.1); margin-bottom: 10px; border-radius: 5px;">
                        <p style="color: {sentiment_color}; margin: 0 0 5px 0; font-weight: bold; text-shadow: 0px 0px 1px rgba(150,150,150,0.3);">Sentiment: {sentiment_category}</p>
                        <p style="margin: 0; color: inherit; font-size: 14px;">{comment_text}</p>
                    </div>
                    """, unsafe_allow_html=True)
            else:
                st.info("No sample comments available for this department")
        else:
            st.error(f"Could not retrieve data for department: {selected_dept}")

def comment_explorer():
    """Comment explorer page"""
    st.title("Comment Explorer")

    if not data_summary:
        st.info("No data loaded. Please upload a file first.")
        st.stop()

    # Filters
    col1, col2, col3 = st.columns(3)

    departments_list = ["All"]
    if departments and isinstance(departments, list):
        departments_list.extend(departments)

    themes_list = ["All"]
    if themes_summary and isinstance(themes_summary, dict):
        themes_list.extend(list(themes_summary.keys()))

    with col1:
        filter_dept = st.selectbox("Department", departments_list)

    with col2:
        filter_theme = st.selectbox("Theme", themes_list)

    with col3:
        filter_sentiment = st.selectbox("Sentiment", ["All", "Positive", "Neutral", "Negative"])

    # Convert filters to API parameters
    api_dept = None if filter_dept == "All" else filter_dept
    api_theme = None if filter_theme == "All" else filter_theme

    # Get comments based on filters
    try:
        comments = get_sample_comments(department=api_dept, theme=api_theme, limit=50)
    except Exception as e:
        st.error(f"Error fetching comments: {str(e)}")
        comments = []

    # Filter by sentiment (client-side)
    if comments and filter_sentiment != "All":
        try:
            filtered_comments = []
            for c in comments:
                # Check if sentiment_score exists, use default if not
                score = c.get("sentiment_score", 0.5)
                sentiment_category = "NEUTRAL"
                if score > 0.6:
                    sentiment_category = "POSITIVE"
                elif score < 0.4:
                    sentiment_category = "NEGATIVE"
                    
                if sentiment_category == filter_sentiment.upper():
                    filtered_comments.append(c)
            comments = filtered_comments
        except Exception as e:
            st.error(f"Error filtering comments by sentiment: {str(e)}")

    # Display comments
    st.subheader(f"Comments ({len(comments) if comments else 0} matching)")

    if comments and isinstance(comments, list):
        for comment in comments:
            if not isinstance(comment, dict):
                continue

            dept = comment.get("department", "Unknown")
            text = comment.get("free_text_comments", "")
            
            # Check if sentiment_score exists, use default if not
            score = comment.get("sentiment_score", 0.5)
            
            # Convert score to sentiment category
            sentiment_category = "NEUTRAL"
            if score > 0.6:
                sentiment_category = "POSITIVE"
            elif score < 0.4:
                sentiment_category = "NEGATIVE"

            sentiment_color = {
                "POSITIVE": "green",
                "NEGATIVE": "red",
                "NEUTRAL": "gray"
            }.get(sentiment_category, "gray")

            st.markdown(f"""
            <div style="padding: 15px; border-left: 5px solid {sentiment_color}; background-color: rgba(0,0,0,0.1); margin-bottom: 15px; border-radius: 5px;">
                <p style="color: lightblue; margin: 0; font-weight: bold;">{dept}</p>
                <p style="color: {sentiment_color}; margin: 5px 0; font-size: 0.9em; font-weight: bold; text-shadow: 0px 0px 1px rgba(150,150,150,0.3);">Sentiment: {sentiment_category.capitalize()} ({score:.2f})</p>
                <p style="margin: 10px 0 0 0; color: inherit; font-size: 14px;">{text}</p>
            </div>
            """, unsafe_allow_html=True)
    else:
        st.info("No comments match the selected filters")

def themes_analysis():
    """Themes analysis page"""
    # Get themes summary
    themes = get_themes_summary()
    
    st.title("Themes Analysis")
    
    # Debug info to help diagnose the issue
    st.sidebar.write(f"DEBUG - Themes data type: {type(themes)}")
    if themes:
        st.sidebar.write(f"DEBUG - Sample themes data: {str(themes)[:200]}...")
    
    # Display themes
    if themes:
        # Create columns for the themes
        cols = st.columns(2)
        
        with cols[0]:
            st.subheader("Overall Theme Distribution")
            
            # Check the format of themes data and convert to a proper format for DataFrame
            theme_data = []
            
            # If themes is already a dictionary of theme->count values
            if isinstance(themes, dict):
                for theme, count in themes.items():
                    # Skip themes containing "comment" as they skew results
                    if "comment" in theme.lower():
                        continue
                    theme_data.append({
                        "theme": theme,
                        "count": count
                    })
            # If themes is a list of dictionaries with 'theme' and 'count' keys
            elif isinstance(themes, list) and all(isinstance(t, dict) for t in themes):
                for t in themes:
                    # Skip themes containing "comment" as they skew results
                    if "comment" in t.get("theme", "").lower():
                        continue
                    theme_data.append(t)
            else:
                st.error(f"Unexpected themes data format: {type(themes)}")
                st.error(f"Themes data: {themes}")
                st.stop()
            
            # Create DataFrame from the properly structured data
            if theme_data:
                theme_df = pd.DataFrame(theme_data)
                theme_df.sort_values(by='count', ascending=False, inplace=True)
                
                # Plot the themes
                fig = px.bar(theme_df, x='theme', y='count', color='count',
                            labels={'count': 'Frequency', 'theme': 'Theme'},
                            title="Theme Frequency (excluding 'comment' themes)",
                            color_continuous_scale=px.colors.sequential.Blues)
                
                fig.update_layout(xaxis_tickangle=-45)
                st.plotly_chart(fig, use_container_width=True)
                
                # Display the table
                st.subheader("Theme Frequency Table")
                st.dataframe(theme_df)
        
        # Use the second column for civility insights
        with cols[1]:
            # Add a section specifically for civility and respect themes
            st.subheader("Civility & Respect Insights")
            
            # Need to ensure theme_df exists from the previous section
            if 'theme_df' in locals():
                # Filter for the civility/respect related themes
                respect_themes = [
                    'respect_communication', 'workplace_culture', 'leadership_behavior',
                    'workplace_policies', 'inclusion_diversity', 'training_development',
                    'recognition_appreciation'
                ]
                
                respect_theme_df = theme_df[theme_df['theme'].isin(respect_themes)] if not theme_df.empty else pd.DataFrame()
                
                if not respect_theme_df.empty:
                    fig2 = px.pie(respect_theme_df, values='count', names='theme', 
                                title="Civility & Respect Themes Breakdown")
                    st.plotly_chart(fig2, use_container_width=True)
                    
                    # Summary of key themes
                    st.subheader("Key Insights for Civility & Respect")
                    
                    # Get top 3 themes if available
                    top_themes = respect_theme_df.head(3)['theme'].tolist() if len(respect_theme_df) >= 3 else respect_theme_df['theme'].tolist()
                    
                    if top_themes:
                        st.markdown("**Top themes related to civility & respect:**")
                        for theme in top_themes:
                            readable_theme = theme.replace('_', ' ').title()
                            st.markdown(f"â€¢ **{readable_theme}** - Get sample comments specific to this theme")
                            
                            # Get comments for this theme
                            theme_comments = get_sample_comments(theme=theme, limit=3)
                            
                            if theme_comments and isinstance(theme_comments, list):
                                for comment in theme_comments:
                                    if not isinstance(comment, dict):
                                        continue
                                    
                                    text = comment.get("free_text_comments", "")
                                    score = comment.get("sentiment_score", 0.5)
                                    
                                    # Convert score to sentiment category
                                    sentiment_category = "NEUTRAL"
                                    if score > 0.6:
                                        sentiment_category = "POSITIVE"
                                    elif score < 0.4:
                                        sentiment_category = "NEGATIVE"
                                    
                                    sentiment_color = {
                                        "POSITIVE": "green",
                                        "NEGATIVE": "red",
                                        "NEUTRAL": "gray"
                                    }.get(sentiment_category, "gray")
                                    
                                    st.markdown(f"""
                                    <div style="padding: 10px; border-left: 5px solid {sentiment_color}; background-color: rgba(0,0,0,0.1); margin-bottom: 10px; border-radius: 5px;">
                                        <p style="color: {sentiment_color}; margin: 0 0 5px 0; font-weight: bold;">Sentiment: {sentiment_category}</p>
                                        <p style="margin: 0; color: inherit; font-size: 14px;">{text}</p>
                                    </div>
                                    """, unsafe_allow_html=True)
                    
                    # Add recommendations
                    st.subheader("Recommendations")
                    st.markdown("""
                    Based on the analysis of feedback, consider the following actions to improve civility and respect:
                    
                    1. **Communication Training**: Provide workshops on respectful communication techniques and active listening.
                    
                    2. **Leadership Development**: Train managers to model respectful behavior and address incivility promptly.
                    
                    3. **Recognition Programs**: Implement formal and informal ways to recognize colleagues who demonstrate respectful behavior.
                    
                    4. **Clear Policies**: Establish clear guidelines for workplace behavior with consistent enforcement.
                    
                    5. **Safe Reporting Channels**: Create confidential channels for reporting disrespectful behavior.
                    
                    6. **Regular Feedback**: Implement periodic surveys to track progress in workplace civility.
                    """)
                else:
                    st.info("No civility and respect themes identified in the data.")
            else:
                st.info("No theme data available to display.")
    else:
        st.info("No theme data available. Please upload data first.")

def about():
    """About page"""
    st.title("About This Dashboard")

    st.markdown("""
    ## Staff Feedback Analysis Tool

    This tool analyzes anonymous staff feedback to identify themes and sentiment in employee comments.

    ### How It Works

    1. **Data Loading**: Upload CSV or Excel files with employee feedback.
    2. **NLP Processing**:
       - Sentiment analysis using DistilBERT transformer model
       - Theme extraction with rule-based pattern matching
    3. **Risk Scoring**:
       - Derived from sentiment scores (more negative sentiment = higher risk)
       - Identification of dominant themes by department
    4. **Dashboard Visualization**:
       - Department risk scores
       - Theme frequency analysis
       - Comment samples with sentiment

    ### Technologies Used

    * **Data Processing**: Pandas
    * **NLP**: Hugging Face Transformers, spaCy
    * **Backend**: FastAPI
    * **Frontend**: Streamlit

    ### Interpreting Results

    * **Sentiment Scores**: 0-1 scale (higher = more positive sentiment)
    * **Risk Scores**: 1-5 scale (higher = higher risk, derived from inverted sentiment)
    * **Themes**: Key topics mentioned in comments (e.g., respect_communication, leadership_behavior)

    This is a specialized version focused on identifying civility and respect themes in workplace feedback.
    """)

def insights_solutions():
    """Insights & Solutions page specifically focused on addressing bullying and harassment"""
    st.title("Insights & Solutions for Improving Workplace Civility")
    
    if not data_summary:
        st.info("No data loaded. Please upload a file using the sidebar.")
        st.stop()
    
    # Get the comments data for analysis
    all_comments = get_sample_comments(limit=500)  # Get as many comments as possible
    
    if not all_comments or not isinstance(all_comments, list) or len(all_comments) == 0:
        st.error("Unable to retrieve comments data. Please ensure data is loaded.")
        st.stop()
    
    # Extract key insights from comments
    # First, classify comments by sentiment and whether they contain a suggested solution
    suggestions = []
    problems = []
    neutral_comments = []
    
    # Track theme occurrences with context
    theme_contexts = {
        'respect_communication': {'problems': [], 'solutions': []},
        'workplace_culture': {'problems': [], 'solutions': []},
        'leadership_behavior': {'problems': [], 'solutions': []},
        'workplace_policies': {'problems': [], 'solutions': []},
        'inclusion_diversity': {'problems': [], 'solutions': []},
        'training_development': {'problems': [], 'solutions': []},
        'recognition_appreciation': {'problems': [], 'solutions': []},
    }
    
    # Common solution phrases that might indicate a suggestion
    solution_phrases = [
        "should", "could", "would help", "needed", "need to", "important to", 
        "recommend", "suggestion", "idea", "propose", "implement", "introduce",
        "start", "begin", "create", "develop", "establish", "set up", "improve",
        "enhance", "boost", "increase", "encourage"
    ]
    
    # Define more specific solution categories for clustering
    specific_solutions = {
        "better_communication": {
            "keywords": ["better communication", "improve communication", "communicate better", "open communication", 
                         "transparent communication", "honest communication", "clear communication", 
                         "communicate openly", "communication channels", "communication skills"],
            "comments": [],
            "display_name": "Better Communication",
            "example_comments": []
        },
        "management_training": {
            "keywords": ["management training", "train managers", "leadership training", "leader training", 
                         "manager development", "train supervisors", "management skills", "leadership development"],
            "comments": [],
            "display_name": "Management/Leadership Training",
            "example_comments": []
        },
        "staff_training": {
            "keywords": ["staff training", "employee training", "training for staff", "train employees", 
                         "professional development", "skills training", "training opportunities", "educational opportunities"],
            "comments": [],
            "display_name": "Staff Training & Development",
            "example_comments": []
        },
        "accountability": {
            "keywords": ["accountability", "hold accountable", "consequences", "responsible", "responsibility", 
                         "addressing issues", "address behavior", "address problems", "take action"],
            "comments": [],
            "display_name": "Accountability Measures",
            "example_comments": []
        },
        "culture_improvement": {
            "keywords": ["better culture", "improve culture", "positive culture", "workplace culture", 
                         "culture change", "respectful culture", "work environment", "atmosphere", "positive environment"],
            "comments": [],
            "display_name": "Culture Improvement",
            "example_comments": []
        },
        "lead_by_example": {
            "keywords": ["lead by example", "leading by example", "role model", "role models", "role modeling", 
                         "set an example", "setting example", "model behavior", "demonstrate"],
            "comments": [],
            "display_name": "Leading by Example",
            "example_comments": []
        },
        "teambuilding": {
            "keywords": ["team building", "team activities", "social events", "get together", "social activities", 
                         "group activities", "team events", "team cohesion", "team bonding"],
            "comments": [],
            "display_name": "Team Building Activities",
            "example_comments": []
        },
        "recognition_programs": {
            "keywords": ["recognition", "rewards", "incentives", "award", "appreciate", "appreciation", 
                         "acknowledge", "acknowledgment", "praise", "compliment"],
            "comments": [],
            "display_name": "Recognition & Appreciation",
            "example_comments": []
        },
        "policy_enforcement": {
            "keywords": ["enforce policy", "policies", "guidelines", "rules", "procedures", "enforce rules", 
                         "clear policies", "policy implementation", "strict enforcement"],
            "comments": [],
            "display_name": "Policy Enforcement",
            "example_comments": []
        },
        "reporting_mechanism": {
            "keywords": ["reporting", "report system", "anonymous reports", "complaint system", "complaint process", 
                         "reporting mechanism", "reporting system", "report concerns", "raise concerns"],
            "comments": [],
            "display_name": "Reporting Mechanisms",
            "example_comments": []
        },
        "zero_tolerance": {
            "keywords": ["zero tolerance", "no tolerance", "not tolerate", "unacceptable", "not accept", 
                         "intolerance", "take seriously", "serious consequences"],
            "comments": [],
            "display_name": "Zero Tolerance Approach",
            "example_comments": []
        },
        "inclusion_diversity": {
            "keywords": ["inclusion", "diversity", "inclusive", "diverse", "equality", "equal treatment", 
                         "equity", "fair treatment", "respect differences", "cultural awareness"],
            "comments": [],
            "display_name": "Inclusion & Diversity",
            "example_comments": []
        },
        "work_life_balance": {
            "keywords": ["work life balance", "work-life balance", "workload", "overworked", "burnout", 
                         "stress reduction", "flexible working", "flexibility", "reasonable hours"],
            "comments": [],
            "display_name": "Work-Life Balance",
            "example_comments": []
        },
        "listening": {
            "keywords": ["listen", "listening", "hear concerns", "hear feedback", "listening skills", 
                         "hear out", "pay attention", "attentive", "active listening"],
            "comments": [],
            "display_name": "Better Listening",
            "example_comments": []
        },
        "feedback_systems": {
            "keywords": ["feedback", "feedback system", "suggestion box", "input", "survey", 
                         "regular feedback", "feedback mechanism", "opinion", "voice concerns"],
            "comments": [],
            "display_name": "Feedback Systems",
            "example_comments": []
        }
    }
    
    for comment in all_comments:
        if not isinstance(comment, dict):
            continue
            
        text = comment.get("free_text_comments", "").lower()
        score = comment.get("sentiment_score", 0.5)
        
        # Skip empty comments
        if not text.strip():
            continue
            
        # Check if comment contains a solution suggestion
        has_solution = any(phrase in text for phrase in solution_phrases)
        
        # Classify comment
        if score < 0.4:  # Negative sentiment - likely describing a problem
            problems.append({"text": text, "score": score})
        elif score > 0.6 or has_solution:  # Positive sentiment or contains solution
            suggestions.append({"text": text, "score": score})
        else:
            neutral_comments.append({"text": text, "score": score})
            
        # Check for themes in this comment
        for theme in theme_contexts.keys():
            if f"theme_{theme}" in comment and comment[f"theme_{theme}"] == 1:
                if has_solution:
                    theme_contexts[theme]['solutions'].append(text)
                else:
                    theme_contexts[theme]['problems'].append(text)
        
        # Classify into specific solution categories
        for solution_key, solution_data in specific_solutions.items():
            for keyword in solution_data["keywords"]:
                if keyword in text:
                    solution_data["comments"].append(text)
                    # Add the first 3 examples only
                    if len(solution_data["example_comments"]) < 3:
                        clean_text = text[:200] + "..." if len(text) > 200 else text
                        if clean_text not in solution_data["example_comments"]:
                            solution_data["example_comments"].append(clean_text)
                    break  # Only count once per comment per solution category
    
    # Create a tab-based interface for different insights
    tabs = st.tabs(["Comment Clustering", "Key Solutions", "Theme Analysis", "Implementation Plan"])
    
    with tabs[0]:
        st.header("Comment Clustering by Solution Type")
        st.markdown("""
        This analysis identifies specific types of solutions mentioned in staff comments and shows exactly 
        how many comments mention each solution approach.
        """)
        
        # Count and sort the specific solutions by frequency
        solution_counts = []
        for sol_key, sol_data in specific_solutions.items():
            count = len(set(sol_data["comments"]))  # Use set to avoid counting duplicates
            if count > 0:
                solution_counts.append({
                    "solution": sol_data["display_name"],
                    "count": count,
                    "key": sol_key
                })
        
        # Sort solutions by count
        solution_counts = sorted(solution_counts, key=lambda x: x["count"], reverse=True)
        
        # Create two columns
        col1, col2 = st.columns([3, 2])
        
        with col1:
            # Create a bar chart of solution counts
            if solution_counts:
                solution_df = pd.DataFrame(solution_counts)
                
                fig = px.bar(
                    solution_df,
                    x="solution",
                    y="count",
                    title="Number of Comments Mentioning Each Solution Type",
                    labels={"solution": "Solution Type", "count": "Number of Comments"},
                    color="count",
                    color_continuous_scale="Viridis"
                )
                fig.update_layout(xaxis_tickangle=-45)
                st.plotly_chart(fig, use_container_width=True)
                
                # Display the data table
                st.subheader("Solution Frequency Table")
                st.dataframe(
                    solution_df[["solution", "count"]].rename(
                        columns={"solution": "Solution Type", "count": "Number of Comments"}
                    )
                )
            else:
                st.info("No specific solutions identified in the comments.")
        
        with col2:
            # Show insights based on the most mentioned solutions
            st.subheader("Key Insights")
            
            if solution_counts:
                top_solutions = solution_counts[:3]
                st.markdown("**Top mentioned solutions:**")
                
                for i, sol in enumerate(top_solutions):
                    st.markdown(f"**{i+1}. {sol['solution']} ({sol['count']} comments)**")
                    
                # Show common trends
                st.markdown("### Common Themes in Solutions")
                st.markdown("""
                Based on the clustering analysis, staff suggestions focus on:
                """)
                
                # Group solutions into broader categories for insight
                communication_count = sum(s["count"] for s in solution_counts if any(x in s["key"] for x in ["communication", "listening", "feedback"]))
                training_count = sum(s["count"] for s in solution_counts if any(x in s["key"] for x in ["training", "development"]))
                accountability_count = sum(s["count"] for s in solution_counts if any(x in s["key"] for x in ["accountability", "enforcement", "zero_tolerance"]))
                culture_count = sum(s["count"] for s in solution_counts if any(x in s["key"] for x in ["culture", "lead_by_example", "inclusion", "recognition"]))
                
                insights = [
                    {"category": "Communication", "count": communication_count},
                    {"category": "Training & Development", "count": training_count},
                    {"category": "Accountability", "count": accountability_count},
                    {"category": "Culture & Recognition", "count": culture_count}
                ]
                
                insights = sorted(insights, key=lambda x: x["count"], reverse=True)
                
                for insight in insights:
                    if insight["count"] > 0:
                        st.markdown(f"â€¢ **{insight['category']}**: {insight['count']} comments")
        
        # Display sample comments for each solution type
        st.subheader("Sample Comments by Solution Type")
        
        # Use expanders for each solution type to keep the UI clean
        for sol in solution_counts:
            sol_key = sol["key"]
            sol_data = specific_solutions[sol_key]
            
            with st.expander(f"{sol_data['display_name']} ({sol['count']} comments)"):
                if sol_data["example_comments"]:
                    for i, comment in enumerate(sol_data["example_comments"]):
                        st.markdown(f"**Example {i+1}:** _{comment.capitalize()}_")
                else:
                    st.info("No example comments available.")
    
    with tabs[1]:
        st.header("Key Solutions from Staff Feedback")
        st.markdown("""
        Staff have provided valuable suggestions on improving workplace civility. 
        Below are the key solutions extracted from their feedback, organized by approach:
        """)
        
        # Display most promising solution areas
        solution_categories = {
            "Communication Improvements": [s for s in suggestions if any(x in s["text"].lower() for x in ["communication", "talk", "listen", "speak", "meeting", "discuss"])],
            "Leadership Actions": [s for s in suggestions if any(x in s["text"].lower() for x in ["leader", "manager", "management", "supervisor", "lead by example", "role model"])],
            "Training & Development": [s for s in suggestions if any(x in s["text"].lower() for x in ["train", "workshop", "course", "learn", "educat", "develop", "skill"])],
            "Policy & Enforcement": [s for s in suggestions if any(x in s["text"].lower() for x in ["policy", "procedure", "rule", "guideline", "enforce", "consequence", "report"])],
            "Recognition & Appreciation": [s for s in suggestions if any(x in s["text"].lower() for x in ["recogni", "appreciat", "reward", "incentiv", "thank", "acknowledge", "praise"])],
        }
        
        # Display solution categories with example comments
        for category, comments in solution_categories.items():
            if not comments:
                continue
                
            st.subheader(category)
            
            # Create bullet points of solution suggestions
            solutions_shown = set()
            bullet_points = []
            
            for comment in sorted(comments, key=lambda x: x["score"], reverse=True)[:5]:  # Top 5 by sentiment
                # Clean and format the comment text for display
                text = comment["text"].capitalize().strip()
                
                # Try to extract just the solution part (often comes after "should", "could", etc.)
                for phrase in ["should", "could", "would", "need to", "important to"]:
                    if phrase in text.lower():
                        parts = text.lower().split(phrase, 1)
                        if len(parts) > 1:
                            solution_text = phrase + parts[1]
                            # Convert to title case and clean up
                            solution_text = solution_text.capitalize().strip()
                            if len(solution_text) > 20 and solution_text not in solutions_shown:
                                bullet_points.append(f"â€¢ {solution_text}")
                                solutions_shown.add(solution_text)
                                break
                
                # If no solution extraction worked, use the full comment
                if not bullet_points or (len(bullet_points) < 2 and len(solutions_shown) < 2):
                    if text not in solutions_shown and len(text) < 200:  # Avoid extremely long comments
                        bullet_points.append(f"â€¢ {text}")
                        solutions_shown.add(text)
            
            # Display the bullet points
            for point in bullet_points[:5]:  # Limit to top 5
                st.markdown(point)
            
            # Add a divider between categories
            st.markdown("---")
    
    with tabs[2]:
        st.header("Theme-Based Analysis")
        
        # Create a deeper analysis of the most relevant themes
        theme_descriptions = {
            "respect_communication": "How staff communicate with each other",
            "workplace_culture": "The overall culture and atmosphere",
            "leadership_behavior": "How leaders and managers behave",
            "workplace_policies": "Formal policies and procedures",
            "training_development": "Training and skill development",
            "recognition_appreciation": "Recognition and appreciation of staff",
        }
        
        # Count problems and solutions by theme
        theme_counts = {}
        for theme, contexts in theme_contexts.items():
            theme_counts[theme] = {
                "problems": len(contexts["problems"]),
                "solutions": len(contexts["solutions"]),
                "total": len(contexts["problems"]) + len(contexts["solutions"])
            }
        
        # Sort themes by total mentions
        sorted_themes = sorted(theme_counts.keys(), key=lambda x: theme_counts[x]["total"], reverse=True)
        
        # Create a summary of key themes with problem/solution breakdown
        theme_summary_data = []
        for theme in sorted_themes:
            counts = theme_counts[theme]
            if counts["total"] > 0:
                theme_summary_data.append({
                    "theme": theme.replace("_", " ").title(),
                    "problems": counts["problems"],
                    "solutions": counts["solutions"],
                    "total": counts["total"]
                })
        
        if theme_summary_data:
            # Create a DataFrame for visualization
            theme_df = pd.DataFrame(theme_summary_data)
            
            # Display stacked bar chart of problems vs solutions by theme
            fig = px.bar(
                theme_df,
                x="theme",
                y=["problems", "solutions"],
                title="Problems vs. Solutions Mentioned by Theme",
                labels={"value": "Count", "theme": "Theme", "variable": "Type"},
                color_discrete_map={"problems": "red", "solutions": "green"},
            )
            fig.update_layout(xaxis_tickangle=-45)
            st.plotly_chart(fig, use_container_width=True)
        
        # Show problem-solution analysis for top 3 themes
        for theme in sorted_themes[:3]:
            if theme_counts[theme]["total"] == 0:
                continue
                
            readable_theme = theme.replace("_", " ").title()
            st.subheader(f"{readable_theme} - Problems & Solutions")
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.markdown("**Key Problems:**")
                if theme_contexts[theme]["problems"]:
                    # Extract the most representative problems
                    representative_problems = list(set([p[:100] + "..." if len(p) > 100 else p for p in theme_contexts[theme]["problems"]]))
                    for problem in representative_problems[:3]:  # Show top 3
                        st.markdown(f"â€¢ {problem.capitalize()}")
                else:
                    st.info("No specific problems identified")
            
            with col2:
                st.markdown("**Proposed Solutions:**")
                if theme_contexts[theme]["solutions"]:
                    # Extract the most representative solutions
                    representative_solutions = list(set([s[:100] + "..." if len(s) > 100 else s for s in theme_contexts[theme]["solutions"]]))
                    for solution in representative_solutions[:3]:  # Show top 3
                        st.markdown(f"â€¢ {solution.capitalize()}")
                else:
                    st.info("No specific solutions proposed")
    
    with tabs[3]:
        st.header("Implementation Plan")
        
        # Create an implementation framework based on the analysis
        st.markdown("""
        Based on the analysis of staff feedback, here is a structured implementation plan 
        to address civility and respect issues in the workplace:
        """)
        
        implementation_steps = [
            {
                "phase": "Immediate Actions (0-30 days)",
                "actions": [
                    "Communicate leadership commitment to addressing the issues",
                    "Establish clear reporting mechanisms for incidents",
                    "Hold team meetings to discuss expectations for workplace behavior",
                ]
            },
            {
                "phase": "Short-term Improvements (1-3 months)",
                "actions": [
                    "Develop/update workplace civility policies",
                    "Implement initial training sessions on respectful communication",
                    "Create a recognition program for positive behaviors",
                ]
            },
            {
                "phase": "Medium-term Solutions (3-6 months)",
                "actions": [
                    "Roll out comprehensive training program for all staff",
                    "Establish ongoing feedback mechanisms",
                    "Develop accountability measures for managers",
                ]
            },
            {
                "phase": "Long-term Culture Change (6-12 months)",
                "actions": [
                    "Integrate civility metrics into performance evaluations",
                    "Create peer support networks",
                    "Regular assessment and adjustment of initiatives",
                ]
            }
        ]
        
        # Display implementation phases
        for phase in implementation_steps:
            st.subheader(phase["phase"])
            for action in phase["actions"]:
                st.markdown(f"â€¢ {action}")
            
            # Add custom actions based on actual feedback
            if phase["phase"] == "Immediate Actions (0-30 days)":
                # Look for immediate actions in the suggestions
                immediate_suggestions = [s for s in suggestions if any(x in s["text"].lower() for x in ["immediately", "urgent", "right away", "as soon as", "start by"])]
                if immediate_suggestions:
                    for sugg in immediate_suggestions[:2]:
                        cleaned_text = sugg["text"].capitalize().strip()
                        if len(cleaned_text) < 100:  # Avoid very long suggestions
                            st.markdown(f"â€¢ {cleaned_text}")
            
            st.markdown("---")
        
        # Add a downloadable resource section
        st.subheader("Resources & Tools")
        st.markdown("""
        The following resources can support implementation:
        
        â€¢ **Workplace Civility Policy Template**
        â€¢ **Communication Training Materials**
        â€¢ **Incident Reporting Form**
        â€¢ **Manager's Guide to Addressing Incivility**
        â€¢ **Recognition Program Framework**
        
        *Note: These would be developed based on the specific needs identified in the feedback.*
        """)

# Main code section starts here
# Now the functions are defined before they are called

# Main content based on selected page
if page == "Home":
    home_page()
elif page == "Department Details":
    department_details()
elif page == "Comment Explorer":
    comment_explorer()
elif page == "Themes Analysis":
    themes_analysis()
elif page == "Insights & Solutions":
    insights_solutions()
else:
    about()

# Display last updated timestamp
if data_summary and "last_updated" in data_summary:
    st.sidebar.markdown(f"**Last Updated**: {data_summary['last_updated']}")

# Run with: streamlit run dashboard.py